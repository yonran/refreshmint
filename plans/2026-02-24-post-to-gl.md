# Plan: Enhance Account Rows Sub-Tab with GL Posting Workflow

## Context

The Pipeline tab's "Account Rows" sub-tab is currently a read-only table (Date / Status / Description / Evidence / Reconciled). Users must switch to the Scrape tab to post entries to the GL, which is confusing. The goal is to make Account Rows an action-oriented view that shows all entries with posted/unposted status and amounts, lets the user set the GL account mapping inline, auto-suggest per-row counterpart accounts (via a token-frequency classifier), and bulk-post or re-sync entries whose amount changed.

---

## Critical Files

- `src/tauri-commands.ts` — `AccountJournalEntry` interface
- `src/App.tsx` — all state, handlers, and JSX (~5549 lines)
    - `AccountJournalTable` component: line 5503
    - Account Rows sub-tab render: lines 3795–3813
    - `pipelineGlRows` memo: lines 484–496
    - `selectedLoginAccount` useEffect (data load): lines 1168–1228
    - `reconcileDrafts` state: line 282 (to be renamed `postDrafts`)
    - `handleReconcileAccountEntry`: line 2440 (scrape-tab version, to be renamed `handlePostAccountEntry`; new `handlePipelinePostEntry` handler needed for pipeline)
    - `setLoginAccount` import: line 57; usage example: line 2064
    - `requestLoginConfigReload()`: line 2075
    - `loginConfigsByName` state: line 216
- `src-tauri/src/lib.rs` — `AccountJournalEntry` struct and `map_account_journal_entries`: lines 1048–1249
- `src-tauri/src/reconcile.rs` → renamed to `post.rs`; `post_login_account_entry`, `unpost_login_account_entry`; `format_gl_transaction` needs `*` status added
- `src-tauri/src/ledger_open.rs` — `run_hledger_print` to be made `pub(crate)`; `build_transaction_rows` has a bug: `id` uses `tindex` (sequential int) instead of the `id` hledger tag (UUID)
- `src-tauri/src/categorize.rs` — new file; token-frequency classifier + amount mismatch detection

---

## Changes

### 0. Full rename: "reconcile" → "post"

The current "reconcile" terminology is incorrect — what the system does is **post** bank entries to the general ledger (creating GL journal transactions). True reconciliation means verifying book balances against bank statements. This rename touches ~344 occurrences across 10 files.

**Rust renames** (all files under `src-tauri/src/`):

- `reconcile.rs` → `post.rs` (rename file + `mod post` in `main.rs`)
- `reconcile_entry` → `post_entry`
- `reconcile_login_account_entry` → `post_login_account_entry`
- `unreconcile_entry` → `unpost_entry`
- `unreconcile_login_account_entry` → `unpost_login_account_entry`
- `reconcile_transfer` → `post_transfer`
- `get_unreconciled_login_account` → `get_unposted_login_account`
- `AccountEntry.reconciled` → `AccountEntry.posted` (field)
- `AccountEntry.reconciled_postings` → `AccountEntry.posted_postings` (field)
- `GlOperation::Reconcile` → `GlOperation::Post`
- `GlOperation::UndoReconcile` → `GlOperation::UndoPost`
- `format_gl_transaction` comment: `generated-by: refreshmint-reconcile` → `generated-by: refreshmint-post`

**On-disk format** (assumes no legacy files — hard assumption; if wrong, old journals/ops will fail to parse. If legacy files exist, add serde aliases and dual-prefix parsing before deploying):

- In `account_journal.rs`: rename `; reconciled:` → `; posted:` and `; reconciled-posting-N:` → `; posted-posting-N:` in both read and write paths.
- In `operations.rs`: rename `"reconcile"` → `"post"` and `"undo-reconcile"` → `"undo-post"` (no serde aliases needed).

**Rename blast-radius checklist** — verify these are all updated:

- Tauri command names in `invoke_handler` (`src-tauri/src/lib.rs`): `reconcile_login_account_entry` → `post_login_account_entry`, `unreconcile_login_account_entry` → `unpost_login_account_entry`, `reconcile_transfer` → `post_transfer`
- CLI `account reconcile` / `account unreconcile` → `account post` / `account unpost`
- Tests in `reconcile.rs` that call functions by old names
- Any hardcoded `"reconcile"` strings in test fixtures or snapshot files

**TypeScript renames** (`src/tauri-commands.ts`, `src/App.tsx`):

- `reconcileLoginAccountEntry` → `postLoginAccountEntry`
- `unreconcileLoginAccountEntry` → `unpostLoginAccountEntry`
- `reconcileTransfer` → `postTransfer`
- `AccountJournalEntry.reconciled` → `AccountJournalEntry.posted`
- `unreconciledEntries` state → `unpostedEntries`
- `reconcileDrafts` → `postDrafts`
- `handleReconcileAccountEntry` → `handlePostAccountEntry`
- All UI labels: "Reconcile" → "Post", "unreconciled" → "unposted", "Reconcile All" → "Post All"

**CLI renames** (`src-tauri/src/cli.rs`):

- `account reconcile` → `account post`
- `account unreconcile` → `account unpost`

### 1. Backend changes

**`src-tauri/src/ledger_open.rs`**:

- Make `run_hledger_print` `pub(crate)` so `categorize.rs` can call it.
- Fix bug in `build_transaction_rows` (line 193): change `id: txn.tindex.to_string()` to extract the `id` hledger tag instead:
    ```rust
    id: txn.ttags.iter()
        .find(|(k, _)| k == "id")
        .map(|(_, v)| v.clone())
        .unwrap_or_else(|| txn.tindex.to_string()),
    ```
    This fixes `pipelineGlRows` which currently fails to match because `tindex` (e.g., `"5"`) never equals a UUID.

**`src-tauri/src/post.rs`** (renamed from `reconcile.rs`) — GL transaction status:

Change `format_gl_transaction` to inherit the status from the account entry:

```rust
let status_marker = entry.status.hledger_marker(); // "" | "! " | "* "
format!("{}  {}{}  ; id: {}\n    ...", entry.date, status_marker, entry.description, gl_txn_id)
```

For transfers, `format_transfer_gl_transaction` must compute a combined status:

```rust
let status_marker = if entry1.status == EntryStatus::Cleared && entry2.status == EntryStatus::Cleared {
    "* "
} else if entry1.status == EntryStatus::Pending || entry2.status == EntryStatus::Pending {
    "! "
} else {
    ""
};
format!("{}  {}{}  ; id: {}\n    ...", entry1.date, status_marker, entry1.description, gl_txn_id)
```

This means:

- Bank transaction is `Cleared` (posted/finalized) → GL txn gets `*` (Cleared) — matches Quicken's "C"
- Bank transaction is `Pending` (not yet posted) → GL txn gets `!` (Pending) — will be promoted to `*` once the pending txn is finalized by a future extraction
- Bank transaction is `Unmarked` → GL txn gets no marker

This is the correct semantic: a GL transaction should only be marked cleared when all its source bank entries are cleared. Pending transactions (unposted activity) stay pending until finalized.

**Fix `unpost` for Transfers**:
Currently, `unpost_entry` and `unpost_login_account_entry` only clear the `posted` tag on the journal entry they were called on. If the GL transaction was a transfer, the _other_ side's entry is left with a dangling `posted` reference.

Strategy: `remove_gl_transaction` already returns `Option<String>` (the removed block text). Exact write order and rollback:

1. Parse `; source: <locator>:<entry_id>` lines from the removed block text (safe — our own generated format).
2. Load ALL other-side account journals into memory (fail fast if any can't be loaded — GL block NOT yet removed at this point).
3. Remove GL block from `general.journal` (point of no return; save returned block for rollback).
4. For each other-side entry in memory, clear its `posted` tag; write each updated journal. If write N fails:
   a. Restore GL block via `append_to_journal` (best-effort).
   b. Attempt to restore already-written journals from their pre-write snapshots.
   c. Return error to caller.
5. Write the triggering entry's own journal last (same rollback applies).
6. Append `UndoPost` to operations log.

**Note**: Steps 3-5 are not fully atomic at the OS level. For a single-user desktop app, partial failure (e.g. power loss between writes) leaves journals in an inconsistent state. A future improvement could use a write-ahead log, but for now the error message should instruct the user to run `cargo run -- verify` to detect and report inconsistencies.

**`src-tauri/src/lib.rs`**:

Add fields to the `AccountJournalEntry` struct (~line 1048):

```rust
amount: Option<String>,   // quantity only, e.g. "-21.32" (no commodity)
tags: Vec<(String, String)>,
```

In `map_account_journal_entries` (line 1225):

```rust
amount: e.postings.first()
    .and_then(|p| p.amount.as_ref())
    .map(|a| a.quantity.clone()),   // quantity string, not formatted
tags: e.tags.clone(),
```

Register new `suggest_categories` Tauri command in `invoke_handler`.

**New file `src-tauri/src/categorize.rs`**:

`suggest_categories(ledger_dir, login_name, label)` → `HashMap<String, CategoryResult>`

Where `CategoryResult` = `{ suggested: Option<String>, amount_changed: bool, status_changed: bool, transfer_match: Option<TransferMatch> }`.
`TransferMatch` = `{ account_locator: String, entry_id: String, matched_amount: String }`.

The command does both category suggestion, amount mismatch detection, and transfer auto-matching in a single pass:

```rust
// ... inside the loop scoring unposted entries:

    // Amount mismatch: compare entry amount vs GL posting amount
    // ...

    // Auto-match Transfers
    let mut transfer_match = None;
    let is_transfer = transfer_detector::is_probable_transfer(&entry.description)
        || entry.tags.iter().any(|(k, v)| k == "isTransfer" && v == "true");

    if entry.posted.is_none() && is_transfer {
        // Search unposted entries in ALL OTHER login accounts.
        // Look for an entry within ±3 days with the EXACT OPPOSITE amount AND same commodity.
        // Only auto-link if EXACTLY ONE candidate matches (unique match).
        // Multiple candidates → leave transfer_match = None (user must manually link).
    }

    // Suggest category from token scores
    let suggested = if entry.posted.is_none() && transfer_match.is_none() {
        score_tokens(&index, &entry.description, &entry.tags)
    } else { None };

    results.insert(entry.id.clone(), CategoryResult { suggested, amount_changed, status_changed, transfer_match });
}
```

**Token extraction** (`tokenize` fn): uppercase description words (alphabetic only, skip numbers/punctuation) + all entry tags as `"key:value"` strings (e.g., `"category:Groceries"`, `"isTransfer:true"`).

**`src/tauri-commands.ts`**:

- Add `amount: string | null` and `tags: [string, string][]` to `AccountJournalEntry`
- Add `export interface TransferMatch { accountLocator: string; entryId: string; matchedAmount: string }`
- Add `export interface CategoryResult { suggested: string | null; amountChanged: boolean; statusChanged: boolean; transferMatch: TransferMatch | null }`
- Add `export async function suggestCategories(ledger, loginName, label): Promise<Record<string, CategoryResult>>`

**Data-loading**: In `useEffect` at line 1168, call `suggestCategories` after the main data loads (not in the `Promise.all` — keep it non-blocking so journal/unposted data appears immediately). If `suggestCategories` fails, log the error and set `pipelineCategorySuggestions` to `{}` (fail-open).

**Async race guard**: Each `suggestCategories` call is tagged with a monotonically-increasing request ID. On completion, only apply the result if the request ID matches the latest (discard stale responses from previous account selections). Pattern:

```ts
const suggestRequestId = useRef(0);
// in the non-blocking call:
const reqId = ++suggestRequestId.current;
suggestCategories(...).then(result => {
    if (reqId === suggestRequestId.current) setPipelineCategorySuggestions(result);
}).catch(...);
```

Also call after each post/sync to refresh mismatch flags (increment request ID each time).

### 2. Frontend state additions — `App.tsx`

Add near existing pipeline state (~line 282):

```ts
const [pipelineSelectedEntryIds, setPipelineSelectedEntryIds] = useState<
    Set<string>
>(new Set());
const [pipelineCategorySuggestions, setPipelineCategorySuggestions] = useState<
    Record<string, CategoryResult>
>({});
const [pipelineGlAccountDraft, setPipelineGlAccountDraft] = useState('');
const [isSavingPipelineGlAccount, setIsSavingPipelineGlAccount] =
    useState(false);
const [isPipelinePosting, setIsPipelinePosting] = useState(false);
```

Add derived state and computed values (after `pipelineGlRows` memo):

```ts
// The GL account currently mapped to the selected pipeline login/label
const pipelineGlAccount: string | null = selectedLoginAccount
    ? (loginConfigsByName[selectedLoginAccount.loginName]?.accounts[
          selectedLoginAccount.label
      ]?.glAccount ??
      null ??
      null)
    : null;
```

Reset `pipelineGlAccountDraft`, `pipelineSelectedEntryIds`, and `pipelineCategorySuggestions` when `selectedLoginAccount` changes (add to the existing useEffect at line 1163). This prevents stale selections from triggering wrong bulk actions on a different account.

### 3. New handlers — `App.tsx`

**`handleSavePipelineGlAccount()`**

- Calls `setLoginAccount(ledger.path, loginName, label, glAccount)` using `selectedLoginAccount`
- Then calls `requestLoginConfigReload()` and reloads pipeline data

**`handlePipelinePostEntry(entryId: string)`**

- Uses `selectedLoginAccount` directly (not `scrapeAccount`)
- If the entry has a `transferMatch` in `pipelineCategorySuggestions[entryId]`:
    - Calls `postTransfer` instead of standard post.
    - Formats the counterpart account argument by parsing the `transferMatch.account_locator`.
- Otherwise:
    - Calls `postLoginAccountEntry` with draft counterpart (or `pipelineCategorySuggestions[entryId]?.suggested` if no per-entry draft)
- Refreshes by calling `getLoginAccountJournal` + `getLoginAccountUnposted` directly (not via `refreshAccountPipelineData` which requires `scrapeAccount`)
- Updates `accountJournalEntries`, `unpostedEntries`

**Manual Transfer Matching Modal**
Remove the old manual "Transfer posting" block entirely (lines 5192-5288 in `App.tsx`).
Instead, if an entry is flagged as a transfer (or if the user clicks a "Link Transfer" button in the row), open a modal that displays all unposted entries from _other_ login accounts. The user can select a row from this modal to explicitly link the two entries as a transfer, bypassing the auto-matcher.

**`handlePipelinePostAll()`**

- Loops all `unpostedEntries`, for each calls `handlePipelinePostEntry` in sequence
- Uses `setIsPipelinePosting(true)` while running
- **Failure semantics**: stop-on-first-error. Report which entry failed with the error message; entries posted before the failure remain posted (do not roll back the whole batch).

**`handlePipelinePostSelected()`**

- Same as above but only for `pipelineSelectedEntryIds`

**`handlePipelineSyncEntry(entryId: string)`**

- Instead of Unpost then Re-post (which breaks commutativity for transfers since both sides detach), introduce a `sync_gl_transaction` Tauri command.
- Refreshes pipeline data + re-runs `suggestCategories` to update mismatch flags

**`amountChanged` / `statusChanged` detection rules** (computed in `suggest_categories`, Rust):

- Retrieve the entry's `posted` GL ref → look up the GL transaction via hledger JSON (`run_hledger_print`)
- Find the posting whose `; source:` tag matches this entry's locator+ID
- **Amount comparison**: parse both amounts as `(commodity, DecimalRaw)`; compare commodity (exact string match) and mantissa after normalizing to the same `decimal_places` (multiply the lower-precision value). `amountChanged = true` if either differs. Sign convention: entry amount and GL posting amount should have opposite signs (entry is debit, GL posting is credit to the GL account).
- **Status comparison**: compare `entry.status.hledger_marker()` against the GL transaction's current `tstatus` marker. `statusChanged = true` if they differ (any change).

**Manual Transfer Matching Modal — backend contract**:
New Tauri command: `get_unposted_entries_for_transfer(ledger_dir, exclude_login, exclude_label) → Vec<AccountJournalEntry>`

- Returns all unposted entries across ALL login accounts EXCEPT `(exclude_login, exclude_label)`.
- Sorted by: date descending, then by abs(amount) descending.
- Frontend filters/searches within the returned list (no server-side filter beyond exclude).

**New `GlOperation` variant** (`src-tauri/src/operations.rs`):

```rust
#[serde(rename = "sync-transaction")]
SyncTransaction {
    account: String,        // source locator, e.g. "logins/chase/accounts/checking"
    #[serde(rename = "entryId")]
    entry_id: String,
    #[serde(rename = "glTxnId")]
    gl_txn_id: String,      // the GL transaction UUID that was updated
    // Snapshot of what changed, so the log entry is self-contained for audit/replay:
    sources: Vec<SyncSource>,   // all source entries involved (not just the trigger entry)
    timestamp: String,
}

// Where SyncSource captures enough to replay:
struct SyncSource {
    account: String,
    entry_id: String,
    amount: Option<String>,    // new amount quantity
    status: String,            // new status marker ("", "!", "*")
}
```

This ensures every GL mutation is logged: `post`, `transfer-match`, `undo-post`, and `sync-transaction`. The log records enough payload (source entry IDs, resulting amounts and status) to audit or replay each sync without needing to re-read the source journals.

**New Rust command: `sync_gl_transaction`** (`src-tauri/src/post.rs`):

- Inputs: `ledger_dir: &Path, login_name: &str, label: &str, entry_id: &str`
- Steps:
    1. Load the account journal entry, get its `posted` GL ref (e.g. `general.journal:uuid`).
    2. Parse the existing GL block from `general.journal` using `split_journal_blocks` to find the block with `; id: <uuid>`.
    3. Parse `; source:` tags from the block to identify all source entries.
    4. For each source, load the account entry to get current amount and status.
    5. Rebuild the GL transaction block with updated amounts and status marker (using existing `format_gl_transaction` / `format_transfer_gl_transaction`).
    6. Replace the old block in `general.journal` with the new block (in-place, same position).
    7. The `posted` tags and `; source:` tags remain unchanged — no links are broken.
    8. Append `GlOperation::SyncTransaction` to the operations log.
- **Write order and failure matrix**:
    1. Read all source entries (fail fast before any writes if any can't be loaded).
    2. Rebuild the new GL block in memory.
    3. Write `general.journal` in-place with the new block (single file write — only GL file changes; account journals are not touched since `posted` refs remain unchanged). If this fails, return error — no partial state.
    4. Append `SyncTransaction` to ops log (best-effort; failure here is non-fatal).
- The sync command is safe to retry (idempotent rewrite of GL block).
- `statusChanged` detection: compare entry's current `status` against the GL transaction's `tstatus` (parsed via hledger JSON). Flag if they differ (any status change, not just Pending→Cleared).

### 4. Account Rows sub-tab replacement — `App.tsx` lines 3795–3813

Replace:

```tsx
) : pipelineSubTab === 'account-rows' ? (
    isLoadingAccountJournal ? (
        <p className="status">Loading account rows...</p>
    ) : (
        <div className="table-wrap">
            <AccountJournalTable entries={accountJournalEntries} />
        </div>
    )
```

With a new section containing:

**a. GL account mapping (if not set)**

```
If pipelineGlAccount is null/empty:
  "GL account not set for this login/label."
  [Assets:Checking:Chase] [Save]
```

Using `pipelineGlAccountDraft` state + `handleSavePipelineGlAccount`.

**b. Auto-categorization + bulk actions**

No single "default category" field. Instead, auto-suggest a category per row via a new Rust Tauri command that runs a token-frequency classifier.

**New Rust command: `suggest_categories`**

```rust
// tauri-commands.ts
export async function suggestCategories(
    ledger: string,
    loginName: string,
    label: string,
): Promise<Record<string, CategoryResult>>  // entry_id → CategoryResult
```

**Algorithm** (new file `src-tauri/src/categorize.rs`):

The classifier is general-purpose — it can suggest any counterpart type: `Expenses:*`, `Assets:*`, `Liabilities:*`, `Income:*`.

Two separate sub-systems:

1. **Transfer detection**: deterministic rule-based (not ML). Uses `transfer_detector::is_probable_transfer` + amount-opposite matching (exact amount, same commodity, ±3 days, unique candidate). Stays explainable and low-false-positive. Runs first; if a transfer match is found, skip category suggestion for that entry.
2. **Category suggestion**: Multinomial Naive Bayes (MNB) with a global+per-account hybrid. Returns `None` (abstain) if max class probability is below a confidence threshold (e.g., 0.5).

**MNB implementation**: use [`linfa-bayes`](https://docs.rs/linfa-bayes/0.8.1/linfa_bayes/struct.MultinomialNb.html) crate (add `linfa-bayes = "0.8"` and `ndarray = "0.15"` to `src-tauri/Cargo.toml`).

Feature encoding: build a vocabulary of all observed tokens → `HashMap<String, usize>`. Represent each training/query example as a count vector `Array1<f64>` (token → count). Stack examples into `Array2<f64>` and fit `MultinomialNbParams::new().alpha(1.0)` (Laplace smoothing).

Confidence filtering: call `predict_proba()` on the query vector; return class suggestion only if `max_prob >= 0.5`, otherwise return `None` (abstain).

**Step 1 — Build seeded global index** (static data in `categorize.rs`):

Seed the global index with a compile-time list of `(token, counterpart_account, count)`. Seeded entries use count=1 so user history (count increments per posted txn) quickly dominates:

- **Bank category tag tokens**: `"category:Groceries"` → `Expenses:Groceries`, etc.
- **Merchant keyword tokens**: `"SAFEWAY"/"KROGER"` → `Expenses:Groceries`, `"STARBUCKS"/"CHIPOTLE"` → `Expenses:Dining`, `"SHELL"/"CHEVRON"` → `Expenses:Gas`, `"AMAZON"/"WALMART"/"TARGET"` → `Expenses:Shopping`, `"NETFLIX"/"SPOTIFY"` → `Expenses:Entertainment`, `"PAYROLL"/"DEPOSIT"` → `Income:Salary`

**Step 2 — Overlay user history (parse GL once)**:

Parse `general.journal` ONCE via `run_hledger_print` (already `pub(crate)`). Build a `HashMap<String, Transaction>` keyed by `id` tag for O(1) lookup. No repeated parses.

For each posted entry in the account journal (`posted = Some("general.journal:uuid")`):

- Look up the GL transaction by UUID in the pre-built index
- Extract counterpart account (the posting that is NOT the GL account)
- Tokenize: uppercase alphabetic words from description + all tags as `"key:value"` strings
- Add tokens to BOTH the **global** index AND the **per-account** index (keyed by `(login_name, label)`)

**Step 3 — Score each unposted entry (hybrid)**:

Build training data by combining seeded examples + user history. For seeded entries, replicate each `(token, class, count)` as `count` synthetic training rows. For user history, each posted entry becomes one training row.

Fit TWO models: a **global model** (all training data) and a **per-account model** (only rows from this `login_name+label`). Encode the query entry as a count vector against the shared vocabulary.

```
global_proba  = global_model.predict_proba(query)
account_proba = account_model.predict_proba(query)   // or global if account has < 2 classes
alpha = min(1.0, account_sample_count / 20.0)
combined_proba = normalize(global_proba + alpha * account_proba)
```

If `max(combined_proba) >= 0.5` → return `Some(argmax_class)`.
Otherwise → return `None` (force manual selection).

**GL journal parsing**: reuse `run_hledger_print` from `ledger_open.rs` (already `pub(crate)`) to get structured JSON — no manual text parsing.

**Frontend**: Call `suggestCategories` when `selectedLoginAccount` changes and data is loaded. Store result in `pipelineCategorySuggestions: Record<string, CategoryResult>`. Use as fallback for the per-row counterpart input.

Bulk actions:

```
[Post All]  [Post Selected]
```

**c. Enhanced table** — all `accountJournalEntries` rows:

- Column: checkbox (disabled for already-posted entries without amount change)
- Columns: Date, Description, Amount (new — from `entry.amount`), Counterpart, Status, Actions

**Status logic per row** (amounts compared in Rust, not frontend):

```ts
const result = pipelineCategorySuggestions[entry.id];
const amountChanged = result?.amountChanged ?? false;
const statusChanged = result?.statusChanged ?? false; // Also flag if the entry transitioned Pending->Cleared

// UI rendering for counterpart:
let counterpartUI;
if (result?.transferMatch) {
  counterpartUI = `Transfer ↔ ${result.transferMatch.account_locator}`;
} else {
  counterpartUI = <input ... /> // standard input
}

if (!entry.posted)          → badge "unposted" + counterpartUI + [Post] button
if (entry.posted && !amountChanged && !statusChanged) → badge "posted" + no counterpart input
if (entry.posted && (amountChanged || statusChanged))  → badge "⚠ needs sync" + [Sync] button
```

Counterpart input per unposted row is pre-filled from `postDrafts[entry.id]?.counterpartAccount || pipelineCategorySuggestions[entry.id]?.suggested`. The suggestion (if confidence >= 0.5) is shown in muted text if the input is empty; if confidence < 0.5 the field is blank (abstain — user must type).

---

## Implementation Order

Each step below should be committed separately with updated tests and docs (README, in-code comments) before moving to the next.

**Step A — Rename "reconcile" → "post"** (purely mechanical, no logic changes)

1. Rename `src-tauri/src/reconcile.rs` → `post.rs`; update `mod` declaration in `main.rs`
2. Rename all functions, struct fields, CLI commands, Tauri command names, operations log variants, on-disk tag prefixes (see §0 rename list and blast-radius checklist)
3. Update all tests to use new names; update any docs that mention "reconcile" in the user-facing sense
4. `cargo build && cargo test` must pass
5. Commit: "rename: reconcile → post throughout"

**Step B — Fix `TransactionRow` UUID bug in `build_transaction_rows`**

1. Change `id: txn.tindex.to_string()` → extract `id` tag from `ttags`
2. Add unit test for both cases (tag present / absent)
3. Commit: "fix: use id hledger tag in build_transaction_rows"

**Step C — GL transaction status propagation**

1. Update `format_gl_transaction` to use `entry.status.hledger_marker()`
2. Update `format_transfer_gl_transaction` to compute combined status
3. Add unit tests for Cleared/Pending/Unmarked combos
4. Commit: "feat: propagate entry status to GL transaction marker"

**Step D — Fix `unpost` for transfers**

1. Extend `unpost_entry` and `unpost_login_account_entry` to clear `posted` on other-side source entries
2. Define exact write order and rollback (see §1 plan); add `get_unposted_entries_for_transfer` command
3. Add unit test: post a transfer, unpost one side, verify both sides are cleared
4. Commit: "fix: unpost clears posted tag on both sides of a transfer"

**Step E — Add `sync_gl_transaction` command**

1. Implement in `post.rs`; add `SyncTransaction` GlOperation variant with sources payload
2. Add unit test: sync updates amounts/status in-place, source/id tags unchanged, ops log entry written
3. Commit: "feat: add sync_gl_transaction command for in-place GL update"

**Step F — Extend `AccountJournalEntry` with `amount` and `tags`**

1. Add fields to Rust struct and `map_account_journal_entries`
2. Add fields to TypeScript `AccountJournalEntry` interface
3. Commit: "feat: expose amount and tags on AccountJournalEntry"

**Step G — New `categorize.rs` with `suggest_categories` command**

1. Add `linfa-bayes = "0.8"` and `ndarray = "0.15"` to `src-tauri/Cargo.toml`
2. Implement vocabulary builder, training data assembler, linfa `MultinomialNb` fit, `predict_proba` inference
3. Wire up transfer auto-matching (rule-based, unique-candidate check)
4. Add `suggest_categories` and `get_unposted_entries_for_transfer` Tauri commands
5. Add unit tests for seeded suggestions, user history overlay, transfer uniqueness, confidence threshold
6. Commit: "feat: add suggest_categories command with MNB classifier"

**Step H — Account Rows sub-tab UI overhaul**

1. Add frontend state, async race guard, derived `pipelineGlAccount`
2. Replace `AccountJournalTable` with new action-oriented table
3. Add GL account mapping inline editor
4. Add Post / Post All / Post Selected buttons with stop-on-first-error semantics
5. Add Manual Transfer Matching Modal (backed by `get_unposted_entries_for_transfer`)
6. Add `handlePipelineSyncEntry` wired to `sync_gl_transaction`
7. Commit: "feat: enhance Account Rows sub-tab with posting workflow"

## Verification

### Rust unit tests (add to `src-tauri/src/post.rs` and `src-tauri/src/categorize.rs`):

1. **ID tag fix**: Test that `build_transaction_rows` uses the `id` hledger tag when present, falls back to `tindex` when absent.
2. **GL status propagation**: Test `format_gl_transaction` with Cleared/Pending/Unmarked entries; test `format_transfer_gl_transaction` with mixed statuses (both cleared → `*`, one pending → `!`, both unmarked → none).
3. **Transfer unpost**: Test that `unpost_login_account_entry` on a transfer GL txn clears `posted` on BOTH source entries.
4. **`sync_gl_transaction`**: Test that syncing updates amounts and status in-place without changing `; source:` or `; id:` tags.
5. **`suggest_categories`**: Test seeded index returns suggestions for known tokens; test user history overrides seeds; test transfer auto-match with unique vs ambiguous candidates.

### Manual / integration testing:

7. Open a ledger with unposted entries → Pipeline → Account Rows → verify amounts, statuses, suggested categories.
8. If GL account mapping missing: verify inline set-mapping field appears.
9. Post All → verify GL entries with correct status markers in `general.journal`.
10. GL Rows sub-tab shows posted entries (was broken before `tindex`→UUID fix).
11. Simulate amount change via dedup update → verify "⚠ needs sync" badge → click Sync → verify GL updated.
12. Scrape tab's existing posting queue still works unchanged.
13. `cargo test` passes.
